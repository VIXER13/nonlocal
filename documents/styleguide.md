# Codestyle guide

Если вы собираетесь стать участником данного проекта, для более продуктивной совместной работы, просьба придерживаться некоторых правил написания кода, представленных в данном документе. Набор данных правил нужен в первую очередь для поддержания единообразия кодовой базы и в то же время собирает в себе некоторые best practies, которые уменьшают количество возможных ошибок или оптимизируют и сокращают итоговый код. Разумеется многие из требований это не более, чем прихоть автора, но попрошу с уважением отнестись к ним, так как C++ слишком богат на синтаксис и возможности его выражения, единого стандарта написания кода нет, поэтому автор выбрал свой способ выражения и просит всех участников следовать его стилю. В то же время буду рад конструктивной критике и замечаниям. Спасибо за понимание и вашу помощь!

Данный документ не является исчерпывающим, просто потому что C++ необъятный язык с кучей нюансов. Пополнение новыми правилами и требованиями к оформлению кода будет постепенным, по мере необходимости. **Золотое правило**: смотрите как написан код до вас и старайтесь писать в том же стиле.

**Стиль кода.**
В качестве стиля для объявления переменных, функций, классов и т.д. был выбран *snake_case* (т.е. каждое слово отделяется нижним подчёркиванием и начинается с маленькой буквы). Для объявления параметров шаблона или именованных констант (в том числе enum) используйте *Snake_Case* (т.е. каждое слово отделяется нижним подчёркиванием и начинается с большой буквы). Использование других стилей не приветствуется, но может встречаться при использовании сторонних библиотек.

**Именование.**
Используйте говорящие названия переменных и функций. Как правило название функции начинается с глагола, а название переменной с существительного. Разумеется это не всегда оправдано, поэтому требования к неймингу не очень строгие.

Названия не должны быть слишком длинными, но в то же время старайтесь избегать сокращений и аббревиатур если они, конечно, не общепризнанные, как, например, slae или json.

**Комментирования кода.**
Для того, чтобы кодовая база не зависила от кодировки, пишите комментарии на английском. Разумно относитесь к комментированию кода, не нужно комментировать каждую строчку, очень часто, что делает код можно понять из названия функции или переменной, но в то же время старайтесь комментировать неочевидные алгоритмические или архитектурные особенности. 

Помните, что система контроля версий git используется не просто так, историю изменения файлов всегда можно посмотреть, поэтому не оставляйте куски отладочного или старого кода под комментариями, они лишь засоряют кодовую базу!

**Отсутупы и оформление.**
При форматировании кода, используйте 4 пробела для отступа каждой следующей вложенной секции. Конечно, самый удобный способ это нажать кнопку Tab, поэтому перед тем как начать писать код, настройте IDE таким образом, чтобы она ставила 4 пробела вместо табуляции.

Не оставляйте много пустых строк между кодом. Максимум одна пустая строка между двумя участками кода.

Строгих ограничений на длину строки нет, однако, в случае если она слишком длинная (примерно 120 знаков и более), делайте переносы. Обычно длинные строки возникают при описании сигнатуры функции, в таком случае переносите передаваемые параметры на следующую строчку.

**Пересечение языка C++ с языком C.**
При использовании стандартной библиотеки не используйте функции из языка C, используйте функции, находящиеся в пространстве имён std. Как правило там всегда найдётся необходимый аналог.

Использование макросов **запрещено**. Для написания обобщённого кода пользуйтесь современными возможностями C++: полиморфизм, шаблоны и т.д.

Используйте using вместо typedef если вам необходимо сделать алиас типа.

По возможности избегайте любых преобразований типов, но если это необходимо, то не используйюти C-style cast, т.е. (type)val. Это небезопасно и часто приводит к неожиданному поведению программы. Используйте С++-style cast: static_cast, dynamic_cast и т.д.; но если есть возможность старайтесь пользоваться операторным преобразованием типов, т.е. Type{val}.

***Замечение***: обычно в промышленном коде принято использовать static_cast и dynamic_cast. Реже используют reinterpteter_cast, как правило это небезопасно и используется только при работе со старыми, ещё написанными на C библиотеками. const_cast практически не пользуются. Если вам потребовалось использовать const_cast, хорошенько задуйматесь, а правильно ли вы делаете, может стоит подумать над другим решением?

**Подключение заголовков.**
C++ чувствителен к порядку подключения заголовков, поэтому при их подключении, просьба пользоваться золотым правилом:

> 1. Заголовок соответствующий текущему .cpp файлу.
> 2. Заголовки текущего проекта.
> 3. Заголовки других проектов.
> 4. Заголовки сторонних библиотек
> 5. Заголовки стандартной библиотеки

Такой порядок заголовков оптимизирует зависимости между модулями проекта и облегчает рефакторинг. Это достаточно общая рекомендация, которая может быть применима и ко многим другим проектам.

В заголовочных файлах не забывайте в самой первой строке написать
>#pragma once

**Подключение сторонних библиотек**
В проекте NonLocFEM не привествуется использование сторонних библиотек и их включение в состав проекта требует дополнительного обоснования. Однако иногда требуемый функционал достаточно сложен для самостоятельной реализации, поэтому при подключении обязательно посоветуйтесь с автором проекта. Важно, чтобы сторонняя библиотека была по возможности header-only, так как это повышает возможность её включения в проект.

**Описание классов и структур**

При описании классов старайтесь следовать следующим правилам. Порядок полей доступа:
>1. private (в class можно опустить, так как по умолчанию в классах поля приватные)
>2. protected
>3. public

Объявляйте уровень доступа на том же уровне, что и слово class.

Порядок описания сущностей в порядке полей доступа:
>1. алиасы
>2. статические константы и переменные
>4. константы и переменные
>6. статические функции
>7. конструкторы
>8. operator=(...)
>9. деструктор
>10. геттеры и сеттеры
>11. методы класса
>12. Виртуальные методы и их перегрузки
>13. friend функции и операторы

То есть вначале идёт описания всех private сущностей, затем всех protected и затем public, где в каждой секции используется вышеописанный порядок определения сущностей.

При описании нестатических констант и переменных используйте перед именем переменной нижнее подчёркивание. А при описании соответствующих геттеров и сеттеров имя этой переменной без нижнего подчёркивания.

***Замечание 1:*** Данный порядок описания имеет лишь рекомендательный характер, так как не всегда удаётся описать класс в соответвии с ним. Единственное требование, которое необходимо выполнять, это описание всех полей класса (т.е. константы и переменные), рядом друг с другом, даже если им необходимо дать разный уровень доступа. Это повышает читабельность кода и позволяет лучше оценить размер объекта класса. Хорошей практикой является объявление всех переменных класса приватными, а далее при необходимости определения соответствующих им геттеров и сеттеров.

***Замечание 2:*** Если все поля и методы должны быть публичными, лучше используйте ключевое слово struct вместо class. Как правило в struct содержатся только переменные.

**Описание сигнатур функций**

При описании сигнатуры функции, пользуйтесь следующим правилом описания порядка аргументов:
>1. output параметры, передаваемые по ссылке. Допускается только в случае если другой способ приводит к существенному снижению производительности. Такие параметры лучше описывать в виде возвращаемого значения из функции (если таких параметров много, возвращать в виде std::pair или std::tuple).
>2. input/output параметры, передаваемые по ссылке. Такие параметры могут влиять на алгоритм, но в то же время изменяются после его работы.
>3. input параметры, передаваемые по константной ссылке.
>4. input параметры, передаваемые по значению.
>5. input параметры, которые могут иметь дефолтное значение. Порядок указания таких параметром определяется частотой, с которой необходимо переопределять эти параметры. Наиболее востребованные описаваются вначале, наименее востребованные остаются в конце.

Например
> std::pair<int32_t, float> foo(std::vector<double>& changeable_vector, const std::map<std::string, int32_t>& constant_map, const int32_t some_value, const double some_factor = 1.0);